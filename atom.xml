<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>William</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://elzhao.github.io/"/>
  <updated>2019-08-04T16:16:52.562Z</updated>
  <id>https://elzhao.github.io/</id>
  
  <author>
    <name>William</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工厂方法模式模式(FactoryMethod Pattern)</title>
    <link href="https://elzhao.github.io/2019/07/28/factorymethod/"/>
    <id>https://elzhao.github.io/2019/07/28/factorymethod/</id>
    <published>2019-07-28T07:04:12.000Z</published>
    <updated>2019-08-04T16:16:52.562Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个创建产品对象的接口，将实际创建工作推迟到子类。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://elzhao.github.io/img/factorymethod/factorymethod-1.png" width="500" height="90"><p>角色：<br>1、    Factory：抽象工厂角色，该角色是工厂方法模式的核心，定义了创建产品接口<br>2、    ConcreteFactory：具体工厂角色，该角色实现了抽象工厂接口<br>3、    Product：抽象产品角色，该角色负责定义产品的共性，实现对产品最抽象的定义<br>4、    ConcreteProduct：具体产品角色，该角色实现抽象产品所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品角色的实例 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>抽象工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Factory &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象工厂方法</span><br><span class="line"> * 具体生产什么产品由子类自行实现</span><br><span class="line"> * </span><br><span class="line"> * @param cls 产品对象类类型</span><br><span class="line"> * @<span class="built_in">return</span> 具体产品对象 </span><br><span class="line"> */</span><br><span class="line">public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; cls);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Product &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 产品类的抽象方法</span><br><span class="line"> * 由具体的产品类实现</span><br><span class="line"> */</span><br><span class="line">public abstract void method();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFactory extends Factory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; cls) &#123;</span><br><span class="line">Product product = null;</span><br><span class="line">try &#123;</span><br><span class="line">product = (Product) Class.forName(cls.getName()).newInstance();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> (T) product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProduct extends Product &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteProduct-&gt;method!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端掉用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Factory factory = new ConcreteFactory();</span><br><span class="line">Product product = factory.createProduct(ConcreteProduct.class);</span><br><span class="line">product.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="工厂方法模式优点如下："><a href="#工厂方法模式优点如下：" class="headerlink" title="工厂方法模式优点如下："></a>工厂方法模式优点如下：</h3><p>1、    良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如果一个调用者需要一个具体的产品对象，只要知道这个产品的类名或约束字符串即可，不用知道创建对象的过程如何，降低了模块间的耦合。<br>2、    优秀的可扩展性。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以适应变化，符合开闭原则。<br>3、    屏蔽产品类。产品类的实现如何变化，调用者都不需要关心，而只需要关心产品的接口，只要接口保持不变，系统的上层模块就不需要发生变化。因为产品的实例化是由工厂类负责的，具体生产何种产品对象是由不同的工厂类决定的。<br>4、    工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心。工厂方法模式符合迪米特法则，也符合依赖倒置原则，只依赖产品类的抽象；另外还符合里氏替换原则，可以使用产品子类替换产品父类。</p><h3 id="工厂方法模式缺点如下："><a href="#工厂方法模式缺点如下：" class="headerlink" title="工厂方法模式缺点如下："></a>工厂方法模式缺点如下：</h3><p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到反射等技术，增加了系统的实现难度。在某些情况比较简单时是否需要使用工厂方法模式需要权衡利弊。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂方法模式在项目中使用得非常频繁，在很多框架的代码中都可以发现工厂方法模式的应用。可使用工厂方法模式的典型场景如下：<br>1、    工厂方法模式是new一个对象的替代品，因此在所有需要生成对象的地方都可以使用，但是需要慎重考虑是否需要增加一个工厂类进行管理，增加代码的复杂度。<br>2、    需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。<br>3、    工厂方法模式可以使用在测试驱动开发的框架下。例如，测试一个类 A，就需要将与类A关联的类B也同时产生出来，使用工厂方法模式可以将类B虚拟出来，避免类A与类B的耦合。<br>工厂方法模式还可以与其他模式混合使用（如模板方法模式、单例模式、原型模式等），从而构造出扩展性更好的设计。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过农场系统演示工厂方法模式的应用。<br>农场管理系统中，每一种农作物都有专门的园丁管理，形成规模化和专业化生产。农场系统的设计图如下图所示。</p><img src="https://elzhao.github.io/img/factorymethod/factorymethod-2.png" width="500" height="90"><p>水果园丁FruitGardener是抽象工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface FruitGardener &#123;</span><br><span class="line"></span><br><span class="line">public Fruit factory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>水果Fruit是抽象产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Fruit &#123;</span><br><span class="line"></span><br><span class="line">//栽种</span><br><span class="line">public void plant();</span><br><span class="line"></span><br><span class="line">//生长</span><br><span class="line">public void grow();</span><br><span class="line"></span><br><span class="line">//收获</span><br><span class="line">public void harvest();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果园丁AppleGardener实现了FruitGardener接口，是一个用于生产苹果的具体工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppleGardener implements FruitGardener &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Fruit <span class="function"><span class="title">factory</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Apple();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>葡萄园丁GrapeGardener实现了FruitGardener接口，是一个用于生产葡萄的具体工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GrapeGardener implements FruitGardener &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Fruit <span class="function"><span class="title">factory</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Grape();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果Apple实现了Fruit接口，是具体产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">plant</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"栽种苹果！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">grow</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"苹果正在生长..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">harvest</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"收获苹果！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>葡萄Grape实现了Fruit接口，是具体产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Grape implements Fruit &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">plant</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"栽种葡萄！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">grow</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"葡萄正在生长..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">harvest</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"收获葡萄！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端应用场景，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">FruitGardener fruitGardener = new AppleGardener();</span><br><span class="line">Fruit apple = fruitGardener.factory();</span><br><span class="line">apple.plant();</span><br><span class="line">apple.grow();</span><br><span class="line">apple.harvest();</span><br><span class="line"></span><br><span class="line">fruitGardener = new GrapeGardener();</span><br><span class="line">Fruit grape = fruitGardener.factory();</span><br><span class="line">grape.plant();</span><br><span class="line">grape.grow();</span><br><span class="line">grape.harvest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="https://elzhao.github.io/img/factorymethod/factorymethod-3.png" width="500" height="90"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>设计模式(Java版)、设计模式之禅、Android源码设计模式。</p>]]></content>
    
    <summary type="html">
    
      工厂方法模式模式就是定义一个创建产品对象的接口，将实际创建工作推迟到子类。
    
    </summary>
    
      <category term="编程" scheme="https://elzhao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://elzhao.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://elzhao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式(Singleton Pattern)</title>
    <link href="https://elzhao.github.io/2019/07/28/singleton/"/>
    <id>https://elzhao.github.io/2019/07/28/singleton/</id>
    <published>2019-07-28T07:04:12.000Z</published>
    <updated>2019-07-28T08:34:24.558Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>确保一个类只有一个实例，并且自行实例化并向整个系统提供访问该实例的方法。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://elzhao.github.io/img/singleton/singleton-1.png" width="500" height="90"><p>角色：<br>1、    Client——高层客户端；<br>2、    Singleton——单例类；</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1、懒汉模式"><a href="#1、懒汉模式" class="headerlink" title="1、懒汉模式"></a>1、懒汉模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">private static LazySingleton mInstance;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">LazySingleton</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized LazySingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == null) &#123;</span><br><span class="line">mInstance = new LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有第一次掉用getInstance()的时候才去实例化，在一定程度节约资源。<br>缺点：每次掉用getInstance()都要进行同步，造成不必要的同步开销</p><h3 id="2、饿汉模式"><a href="#2、饿汉模式" class="headerlink" title="2、饿汉模式"></a>2、饿汉模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">private static HungrySingleton mInstance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">HungrySingleton</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static HungrySingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：类加载的时候就去实例化避免线程同步问题。<br>缺点：类加载的时候就去实例化造成资源不必要的浪费。</p><h3 id="3、双重检查单例模式"><a href="#3、双重检查单例模式" class="headerlink" title="3、双重检查单例模式"></a>3、双重检查单例模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DclSingleton &#123;</span><br><span class="line"></span><br><span class="line">private volatile static DclSingleton mInstance;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">DclSingleton</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static DclSingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == null) &#123;</span><br><span class="line">synchronized (DclSingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == null) &#123;</span><br><span class="line">mInstance = new DclSingleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有第一次掉用getInstance()的时候才去实例化；双空检查避免了不必要的同步。<br>缺点：在高并发或低于JDK6的环境下有一定缺陷。</p><h3 id="4、静态内部类模式"><a href="#4、静态内部类模式" class="headerlink" title="4、静态内部类模式"></a>4、静态内部类模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SicSingleton &#123;</span><br><span class="line"></span><br><span class="line">private static class SicSingletonHolder&#123;</span><br><span class="line">private static final SicSingleton INSTANCE = new SicSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">SicSingleton</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static SicSingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> SicSingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有第一次掉用getInstance()的时候才去实例化。<br>缺点：特殊情况下失效。</p><h3 id="5、枚举单例模式"><a href="#5、枚举单例模式" class="headerlink" title="5、枚举单例模式"></a>5、枚举单例模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">INSTANCE;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> getClass().getName() + <span class="string">"@"</span> + hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：线程安全；避免多线程同步问题；能够通过反射、反序列化重新创建新的对象。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、在整个项目中需要一个共享访问点，如网站的计数器<br>2、创建一个对象需要消耗过多的资源，如访问网络、IO和数据库等资源<br>3、要求生成唯一序列号的环境</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="单例模式优点："><a href="#单例模式优点：" class="headerlink" title="单例模式优点："></a>单例模式优点：</h3><p>1、    由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。<br>2、    由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。<br>3、    单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。<br>4、    单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</p><h3 id="单例模式缺点："><a href="#单例模式缺点：" class="headerlink" title="单例模式缺点："></a>单例模式缺点：</h3><p>1、    单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。<br>2、    单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。<br>3、    单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在以上单例模式实现中，除枚举单例模式外，其他单例模式在特殊情况下有可能被破坏：<br>1、    通过反射能够生成多个不同实例；<br>2、    如果单例类实现了java.io.Serializable接口，通过序列化反序列化可以还原出多个实例；<br>3、使用克隆生成多个不同实例；</p><p>对第1个问题，懒汉单例模式和内部类单例模式的解决办法：<br><img src="https://elzhao.github.io/img/singleton/singleton-2.png" width="500" height="90"></p><p>对第2个问题的解决办法：<br><img src="https://elzhao.github.io/img/singleton/singleton-3.png" width="500" height="90"></p><p>对第3个问题的解决方法：<br><img src="https://elzhao.github.io/img/singleton/singleton-4.png" width="500" height="90"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>设计模式(Java版)、设计模式之禅、Android源码设计模式。</p>]]></content>
    
    <summary type="html">
    
      单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。
    
    </summary>
    
      <category term="编程" scheme="https://elzhao.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://elzhao.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://elzhao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://elzhao.github.io/2019/07/20/hello-world/"/>
    <id>https://elzhao.github.io/2019/07/20/hello-world/</id>
    <published>2019-07-20T07:40:49.802Z</published>
    <updated>2019-07-28T08:35:37.898Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://elzhao.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程" scheme="https://elzhao.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="感悟" scheme="https://elzhao.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>

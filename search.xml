<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抽象工厂模式(AbstractFactory Pattern)</title>
      <link href="/2019/10/08/abstractfactory/"/>
      <url>/2019/10/08/abstractfactory/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为创建一组相关或相互依赖的对象提供一个接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://elzhao.github.io/img/abstractfactory/abstractfactory-1.png" width="500" height="90"><p>角色：<br>1、    AbstractFactory：抽象工厂角色，声明一组创建产品的方法，每一个方法对应一个产品，如上图中定义了两种方法，分别用于创建产品A和产品B<br>2、    ConcreteFactory：具体工厂角色，实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中，如上图中的ConcreteFactory1和ConcreteFactory2<br>3、    AbstractProduct：抽象产品角色，它为每种产品声明接口，如上图中的AbstractProductA和AbstractProductB<br>4、    ConcreteProduct：具体产品角色，它定义了具体工厂生产的具体产品对象，实现抽象产品中声明的业务方法，如 上图中的ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>抽象产品类A：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractProductA &#123;</span><br><span class="line"></span><br><span class="line">//每个具体产品子类需要实现的方法</span><br><span class="line">public abstract void methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象产品类B：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractProductB &#123;</span><br><span class="line"></span><br><span class="line">//每个具体产品子类需要实现的方法</span><br><span class="line">public abstract void methodB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类A1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProductA1 extends AbstractProductA &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">methodA</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteProductA1 - methodA"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类A2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProductA2 extends AbstractProductA &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">methodA</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteProductA2 - methodA"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类B1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProductB1 extends AbstractProductB &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">methodB</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteProductB1 - methodB"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类B2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProductB2 extends AbstractProductB &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">methodB</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteProductB2 - methodB"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">//创建产品A</span><br><span class="line">public abstract AbstractProductA createProductA();</span><br><span class="line"></span><br><span class="line">//创建产品B</span><br><span class="line">public abstract AbstractProductB createProductB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂类1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFactory1 implements AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public AbstractProductA <span class="function"><span class="title">createProductA</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new ConcreteProductA1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public AbstractProductB <span class="function"><span class="title">createProductB</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new ConcreteProductB1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂类2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFactory2 implements AbstractFactory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public AbstractProductA <span class="function"><span class="title">createProductA</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new ConcreteProductA2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public AbstractProductB <span class="function"><span class="title">createProductB</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new ConcreteProductB2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端掉用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//定义两个工厂</span><br><span class="line">AbstractFactory factory1 = new ConcreteFactory1();</span><br><span class="line">AbstractFactory factory2 = new ConcreteFactory2();</span><br><span class="line">//生产具体产品A1</span><br><span class="line">AbstractProductA productA1 = factory1.createProductA();</span><br><span class="line">//生产具体产品B1</span><br><span class="line">AbstractProductB productB1 = factory1.createProductB();</span><br><span class="line">//生产具体产品A2</span><br><span class="line">AbstractProductA productA2 = factory2.createProductA();</span><br><span class="line">//生产具体产品B2</span><br><span class="line">AbstractProductB productB2 = factory2.createProductB();</span><br><span class="line">productA1.methodA();</span><br><span class="line">productB1.methodB();</span><br><span class="line">productA2.methodA();</span><br><span class="line">productB2.methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="抽象工厂模式优点如下："><a href="#抽象工厂模式优点如下：" class="headerlink" title="抽象工厂模式优点如下："></a>抽象工厂模式优点如下：</h3><p>抽象工厂模式是工厂方法模式的进一步抽象，针对的是一族产品。如果产品族中只有一种产品，则抽象工厂模式就退化为工厂方法模式。除了工厂方法模式的优点外，抽象工厂模式还具有下列优点<br>1、    可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理<br>2、    产品族内的约束为非公开状态，在不同的工厂中，各种产品可能具有不同的相互依赖关系，这些依赖关系由工厂封装在其内部，对于工厂的使用者是不可见的。<br>3、    生产线的扩展非常容易，如果要针对同一产品族建立新的生产线，只需要实现产品族中的所有产品接口并建立新的工厂类即可。</p><h3 id="抽象工厂模式缺点如下："><a href="#抽象工厂模式缺点如下：" class="headerlink" title="抽象工厂模式缺点如下："></a>抽象工厂模式缺点如下：</h3><p>抽象工厂模式的最大缺点就是产品族本身的扩展非常困难，如果需要在产品族中增加一个新的产品类型，则需要修改多个接口，并且会影响已有的工厂类。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。<br>抽象工厂模式通常适用于以下场景：<br>1、    当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。<br>2、    系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。<br>3、    系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过农场系统演示抽象工厂模式的应用。<br>农场中除了种植植物，还可以培养一些动物，如养鸡、养鱼、种菜、种水果等，所以本例比工厂模式介绍的农场系统复杂，必须用抽象工厂模式来实现。<br>本例用抽象工厂模式来设计两个农场，一个是东辛农场用于养鸡和种菜，一个是云台农场用于养鱼和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。<br>类图如下：</p><img src="https://elzhao.github.io/img/abstractfactory/abstractfactory-2.png" width="500" height="90"><p>Animal接口是抽象产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品动物类</span><br><span class="line">public interface Animal &#123;</span><br><span class="line"></span><br><span class="line">public void show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chicken类实现了Animal接口是具体产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//具体产品：鸡类</span><br><span class="line">public class Chicken implements Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"I am a chicken!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fish类实现了Animal接口是具体产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//具体产品：鱼类</span><br><span class="line">public class Fish implements Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"I am a Fish!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Plant接口是抽象产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品植物类</span><br><span class="line">public interface Plant &#123;</span><br><span class="line"></span><br><span class="line">public void show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vagetables类实现了Plant接口是具体产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//具体产品：蔬菜</span><br><span class="line">public class Vegetables implements Plant &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"I am vegetables!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fruit类实现了Plant接口是具体产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//具体产品：水果类</span><br><span class="line">public class Fruit implements Plant &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"I am fruit!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Farm接口是抽象工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//抽象工厂：农场类</span><br><span class="line">public interface Farm &#123;</span><br><span class="line"></span><br><span class="line">public Animal newAnimal();</span><br><span class="line"></span><br><span class="line">public Plant newPlant();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DsFarm类实现了Farm接口是具体工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//具体农场：东辛农场</span><br><span class="line">public class DsFarm implements Farm &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Animal <span class="function"><span class="title">newAnimal</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Chicken();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Plant <span class="function"><span class="title">newPlant</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Vegetables();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>YtFarm类实现了Farm接口是具体工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//具体农场：云台农场</span><br><span class="line">public class YtFarm implements Farm &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Animal <span class="function"><span class="title">newAnimal</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Fish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Plant <span class="function"><span class="title">newPlant</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Fruit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端应用场景，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//东辛农场养鸡种植蔬菜</span><br><span class="line">Farm dsFarm = new DsFarm();</span><br><span class="line">Animal chicken = dsFarm.newAnimal();</span><br><span class="line">Plant vegetables = dsFarm.newPlant();</span><br><span class="line">chicken.show();</span><br><span class="line">vegetables.show();</span><br><span class="line"></span><br><span class="line">//云台农场养鱼种植水果</span><br><span class="line">Farm ytFarm = new YtFarm();</span><br><span class="line">Animal fish = ytFarm.newAnimal();</span><br><span class="line">Plant fruit = ytFarm.newPlant();</span><br><span class="line">fish.show();</span><br><span class="line">fruit.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="https://elzhao.github.io/img/abstractfactory/abstractfactory-3.png" width="150" height="30"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>设计模式(Java版)、设计模式之禅、Android源码设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式(FactoryMethod Pattern)</title>
      <link href="/2019/08/04/factorymethod/"/>
      <url>/2019/08/04/factorymethod/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个创建产品对象的接口，将实际创建工作推迟到子类。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://elzhao.github.io/img/factorymethod/factorymethod-1.png" width="500" height="90"><p>角色：<br>1、    Factory：抽象工厂角色，该角色是工厂方法模式的核心，定义了创建产品接口<br>2、    ConcreteFactory：具体工厂角色，该角色实现了抽象工厂接口<br>3、    Product：抽象产品角色，该角色负责定义产品的共性，实现对产品最抽象的定义<br>4、    ConcreteProduct：具体产品角色，该角色实现抽象产品所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品角色的实例 </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>抽象工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Factory &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 抽象工厂方法</span><br><span class="line"> * 具体生产什么产品由子类自行实现</span><br><span class="line"> * </span><br><span class="line"> * @param cls 产品对象类类型</span><br><span class="line"> * @<span class="built_in">return</span> 具体产品对象 </span><br><span class="line"> */</span><br><span class="line">public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; cls);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Product &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 产品类的抽象方法</span><br><span class="line"> * 由具体的产品类实现</span><br><span class="line"> */</span><br><span class="line">public abstract void method();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteFactory extends Factory &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; cls) &#123;</span><br><span class="line">Product product = null;</span><br><span class="line">try &#123;</span><br><span class="line">product = (Product) Class.forName(cls.getName()).newInstance();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> (T) product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProduct extends Product &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"ConcreteProduct-&gt;method!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端掉用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Factory factory = new ConcreteFactory();</span><br><span class="line">Product product = factory.createProduct(ConcreteProduct.class);</span><br><span class="line">product.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="工厂方法模式优点如下："><a href="#工厂方法模式优点如下：" class="headerlink" title="工厂方法模式优点如下："></a>工厂方法模式优点如下：</h3><p>1、    良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如果一个调用者需要一个具体的产品对象，只要知道这个产品的类名或约束字符串即可，不用知道创建对象的过程如何，降低了模块间的耦合。<br>2、    优秀的可扩展性。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以适应变化，符合开闭原则。<br>3、    屏蔽产品类。产品类的实现如何变化，调用者都不需要关心，而只需要关心产品的接口，只要接口保持不变，系统的上层模块就不需要发生变化。因为产品的实例化是由工厂类负责的，具体生产何种产品对象是由不同的工厂类决定的。<br>4、    工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心。工厂方法模式符合迪米特法则，也符合依赖倒置原则，只依赖产品类的抽象；另外还符合里氏替换原则，可以使用产品子类替换产品父类。</p><h3 id="工厂方法模式缺点如下："><a href="#工厂方法模式缺点如下：" class="headerlink" title="工厂方法模式缺点如下："></a>工厂方法模式缺点如下：</h3><p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到反射等技术，增加了系统的实现难度。在某些情况比较简单时是否需要使用工厂方法模式需要权衡利弊。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>工厂方法模式在项目中使用得非常频繁，在很多框架的代码中都可以发现工厂方法模式的应用。可使用工厂方法模式的典型场景如下：<br>1、    工厂方法模式是new一个对象的替代品，因此在所有需要生成对象的地方都可以使用，但是需要慎重考虑是否需要增加一个工厂类进行管理，增加代码的复杂度。<br>2、    需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。<br>3、    工厂方法模式可以使用在测试驱动开发的框架下。例如，测试一个类 A，就需要将与类A关联的类B也同时产生出来，使用工厂方法模式可以将类B虚拟出来，避免类A与类B的耦合。<br>工厂方法模式还可以与其他模式混合使用（如模板方法模式、单例模式、原型模式等），从而构造出扩展性更好的设计。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过农场系统演示工厂方法模式的应用。<br>农场管理系统中，每一种农作物都有专门的园丁管理，形成规模化和专业化生产。农场系统的设计图如下图所示。</p><img src="https://elzhao.github.io/img/factorymethod/factorymethod-2.png" width="500" height="90"><p>水果园丁FruitGardener是抽象工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface FruitGardener &#123;</span><br><span class="line"></span><br><span class="line">public Fruit factory();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>水果Fruit是抽象产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Fruit &#123;</span><br><span class="line"></span><br><span class="line">//栽种</span><br><span class="line">public void plant();</span><br><span class="line"></span><br><span class="line">//生长</span><br><span class="line">public void grow();</span><br><span class="line"></span><br><span class="line">//收获</span><br><span class="line">public void harvest();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果园丁AppleGardener实现了FruitGardener接口，是一个用于生产苹果的具体工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppleGardener implements FruitGardener &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Fruit <span class="function"><span class="title">factory</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Apple();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>葡萄园丁GrapeGardener实现了FruitGardener接口，是一个用于生产葡萄的具体工厂，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class GrapeGardener implements FruitGardener &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Fruit <span class="function"><span class="title">factory</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> new Grape();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果Apple实现了Fruit接口，是具体产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Apple implements Fruit &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">plant</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"栽种苹果！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">grow</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"苹果正在生长..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">harvest</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"收获苹果！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>葡萄Grape实现了Fruit接口，是具体产品，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Grape implements Fruit &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">plant</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"栽种葡萄！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">grow</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"葡萄正在生长..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">harvest</span></span>() &#123;</span><br><span class="line">System.out.println(<span class="string">"收获葡萄！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端应用场景，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">FruitGardener fruitGardener = new AppleGardener();</span><br><span class="line">Fruit apple = fruitGardener.factory();</span><br><span class="line">apple.plant();</span><br><span class="line">apple.grow();</span><br><span class="line">apple.harvest();</span><br><span class="line"></span><br><span class="line">fruitGardener = new GrapeGardener();</span><br><span class="line">Fruit grape = fruitGardener.factory();</span><br><span class="line">grape.plant();</span><br><span class="line">grape.grow();</span><br><span class="line">grape.harvest();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="https://elzhao.github.io/img/factorymethod/factorymethod-3.png" width="150" height="30"><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>设计模式(Java版)、设计模式之禅、Android源码设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式(Singleton Pattern)</title>
      <link href="/2019/07/28/singleton/"/>
      <url>/2019/07/28/singleton/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>确保一个类只有一个实例，并且自行实例化并向整个系统提供访问该实例的方法。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><img src="https://elzhao.github.io/img/singleton/singleton-1.png" width="500" height="90"><p>角色：<br>1、    Client——高层客户端；<br>2、    Singleton——单例类；</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1、懒汉模式"><a href="#1、懒汉模式" class="headerlink" title="1、懒汉模式"></a>1、懒汉模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">private static LazySingleton mInstance;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">LazySingleton</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized LazySingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == null) &#123;</span><br><span class="line">mInstance = new LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有第一次掉用getInstance()的时候才去实例化，在一定程度节约资源。<br>缺点：每次掉用getInstance()都要进行同步，造成不必要的同步开销</p><h3 id="2、饿汉模式"><a href="#2、饿汉模式" class="headerlink" title="2、饿汉模式"></a>2、饿汉模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">private static HungrySingleton mInstance = new HungrySingleton();</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">HungrySingleton</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static HungrySingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：类加载的时候就去实例化避免线程同步问题。<br>缺点：类加载的时候就去实例化造成资源不必要的浪费。</p><h3 id="3、双重检查单例模式"><a href="#3、双重检查单例模式" class="headerlink" title="3、双重检查单例模式"></a>3、双重检查单例模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class DclSingleton &#123;</span><br><span class="line"></span><br><span class="line">private volatile static DclSingleton mInstance;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">DclSingleton</span></span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static DclSingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == null) &#123;</span><br><span class="line">synchronized (DclSingleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span> (mInstance == null) &#123;</span><br><span class="line">mInstance = new DclSingleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> mInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有第一次掉用getInstance()的时候才去实例化；双空检查避免了不必要的同步。<br>缺点：在高并发或低于JDK6的环境下有一定缺陷。</p><h3 id="4、静态内部类模式"><a href="#4、静态内部类模式" class="headerlink" title="4、静态内部类模式"></a>4、静态内部类模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SicSingleton &#123;</span><br><span class="line"></span><br><span class="line">private static class SicSingletonHolder&#123;</span><br><span class="line">private static final SicSingleton INSTANCE = new SicSingleton();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="function"><span class="title">SicSingleton</span></span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static SicSingleton <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> SicSingletonHolder.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：只有第一次掉用getInstance()的时候才去实例化。<br>缺点：特殊情况下失效。</p><h3 id="5、枚举单例模式"><a href="#5、枚举单例模式" class="headerlink" title="5、枚举单例模式"></a>5、枚举单例模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">INSTANCE;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line"><span class="built_in">return</span> getClass().getName() + <span class="string">"@"</span> + hashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：线程安全；避免多线程同步问题；能够通过反射、反序列化重新创建新的对象。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>1、在整个项目中需要一个共享访问点，如网站的计数器<br>2、创建一个对象需要消耗过多的资源，如访问网络、IO和数据库等资源<br>3、要求生成唯一序列号的环境</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="单例模式优点："><a href="#单例模式优点：" class="headerlink" title="单例模式优点："></a>单例模式优点：</h3><p>1、    由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。<br>2、    由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。<br>3、    单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。<br>4、    单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</p><h3 id="单例模式缺点："><a href="#单例模式缺点：" class="headerlink" title="单例模式缺点："></a>单例模式缺点：</h3><p>1、    单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。<br>2、    单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。<br>3、    单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在以上单例模式实现中，除枚举单例模式外，其他单例模式在特殊情况下有可能被破坏：<br>1、    通过反射能够生成多个不同实例；<br>2、    如果单例类实现了java.io.Serializable接口，通过序列化反序列化可以还原出多个实例；<br>3、使用克隆生成多个不同实例；</p><p>对第1个问题，懒汉单例模式和内部类单例模式的解决办法：<br><img src="https://elzhao.github.io/img/singleton/singleton-2.png" width="500" height="90"></p><p>对第2个问题的解决办法：<br><img src="https://elzhao.github.io/img/singleton/singleton-3.png" width="500" height="90"></p><p>对第3个问题的解决方法：<br><img src="https://elzhao.github.io/img/singleton/singleton-4.png" width="500" height="90"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>设计模式(Java版)、设计模式之禅、Android源码设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/20/hello-world/"/>
      <url>/2019/07/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
